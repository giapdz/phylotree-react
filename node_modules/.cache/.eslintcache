[{"D:\\app test\\phylotree-react\\src\\index.js":"1","D:\\app test\\phylotree-react\\src\\App.js":"2","D:\\app test\\phylotree-react\\src\\lib\\components\\PhylotreeApplication.jsx":"3","D:\\app test\\phylotree-react\\src\\lib\\components\\phylotree.jsx":"4","D:\\app test\\phylotree-react\\src\\lib\\components\\tooltip_container.jsx":"5","D:\\app test\\phylotree-react\\src\\lib\\components\\text_width.jsx":"6","D:\\app test\\phylotree-react\\src\\lib\\components\\svg.jsx":"7","D:\\app test\\phylotree-react\\src\\lib\\components\\branch.jsx":"8"},{"size":411,"mtime":1633119310373,"results":"9","hashOfConfig":"10"},{"size":2933,"mtime":1642958341105,"results":"11","hashOfConfig":"10"},{"size":21163,"mtime":1642958361524,"results":"12","hashOfConfig":"10"},{"size":11949,"mtime":1635840065564,"results":"13","hashOfConfig":"10"},{"size":469,"mtime":1635597344895,"results":"14","hashOfConfig":"10"},{"size":174,"mtime":1635597360075,"results":"15","hashOfConfig":"10"},{"size":820,"mtime":1635597217426,"results":"16","hashOfConfig":"10"},{"size":74342,"mtime":1635778404233,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"o0q68g",{"filePath":"21","messages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"25","messages":"26","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27","usedDeprecatedRules":"20"},{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"30","messages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"D:\\app test\\phylotree-react\\src\\index.js",[],["36","37"],"D:\\app test\\phylotree-react\\src\\App.js",[],"D:\\app test\\phylotree-react\\src\\lib\\components\\PhylotreeApplication.jsx",["38","39","40","41"],"D:\\app test\\phylotree-react\\src\\lib\\components\\phylotree.jsx",["42"],"import { max } from \"d3-array\";\r\nimport { scaleLinear, scaleOrdinal } from \"d3-scale\";\r\nimport { schemeCategory10 } from \"d3-scale-chromatic\";\r\nimport { phylotree } from \"phylotree\";\r\nimport React, { useEffect, useRef, useState } from \"react\";\r\nimport _ from \"underscore\";\r\nimport Branch from \"./branch\";\r\nimport SVG from \"./svg\";\r\nimport text_width from \"./text_width\";\r\n\r\nfunction x_branch_lengths(node, accessor) {\r\n    if (!node.parent) return 0;\r\n\r\n    const bl = accessor(node);\r\n    return bl + node.parent.data.abstract_x;\r\n}\r\n\r\nfunction x_no_branch_lengths(node) {\r\n    return node.parent ? node.parent.data.abstract_x + 1 : 2;\r\n}\r\n\r\nfunction default_accessor(node) {\r\n    return +node.data.attribute;\r\n}\r\n\r\nfunction sort_nodes(tree, direction) {\r\n    tree.traverse_and_compute(function (n) {\r\n        var d = 1;\r\n        if (n.children && n.children.length) {\r\n            d += max(n.children, function (d) {\r\n                return d[\"count_depth\"];\r\n            });\r\n        }\r\n        n[\"count_depth\"] = d;\r\n    });\r\n    const asc = direction === \"ascending\";\r\n    tree.resortChildren(function (a, b) {\r\n        return (a[\"count_depth\"] - b[\"count_depth\"]) * (asc ? 1 : -1);\r\n    });\r\n}\r\n\r\nfunction toggleCollapse(tree, nodes) {\r\n    nodes.map(function (node) {\r\n        if (node.collapsed) {\r\n            node.collapsed = false;\r\n            let unhide = function (n) {\r\n                if (!tree.isLeafNode(n)) {\r\n                    if (!n.collapsed) {\r\n                        n.children.forEach(unhide);\r\n                    }\r\n                }\r\n                n.hidden = true;\r\n            };\r\n\r\n            unhide(node);\r\n        } else {\r\n            node.collapsed = true;\r\n        }\r\n    });\r\n}\r\n\r\nfunction placenodes(tree, perform_internal_layout, accessor, sort, collapse) {\r\n    accessor = accessor || default_accessor;\r\n    if (sort) {\r\n        sort_nodes(tree, sort);\r\n    }\r\n    if (collapse) {\r\n        toggleCollapse(tree, collapse);\r\n    }\r\n    var current_leaf_height = -1,\r\n        unique_id = 0;\r\n    tree.max_x = 0;\r\n    const has_branch_lengths = Boolean(accessor(tree.getTips()[0])),\r\n        x_branch_length = has_branch_lengths\r\n            ? x_branch_lengths\r\n            : x_no_branch_lengths;\r\n    function node_layout(node) {\r\n        if (!node.unique_id) {\r\n            unique_id = node.unique_id = unique_id + 1;\r\n        }\r\n        node.data.abstract_x = x_branch_length(node, accessor);\r\n        tree.max_x = Math.max(tree.max_x, node.data.abstract_x);\r\n        if (node.children) {\r\n            node.data.abstract_y =\r\n                node.children.map(node_layout).reduce((a, b) => a + b, 0) /\r\n                node.children.length;\r\n        } else {\r\n            current_leaf_height = node.data.abstract_y =\r\n                current_leaf_height + 1;\r\n        }\r\n        return node.data.abstract_y;\r\n    }\r\n\r\n    function internal_node_layout(node) {\r\n        unique_id = node.unique_id = unique_id + 1;\r\n        node.data.abstract_x = x_branch_length(node, accessor);\r\n        tree.max_x = Math.max(tree.max_x, node.data.abstract_x);\r\n        if (!tree.isLeafNode(node)) {\r\n            node.children.forEach(internal_node_layout);\r\n        }\r\n        if (!node.data.abstract_y && node.data.name !== \"root\") {\r\n            current_leaf_height = node.data.abstract_y =\r\n                current_leaf_height + 1;\r\n            tree.nodeOrder.push(node.data.name);\r\n        }\r\n        if (\r\n            node.parent &&\r\n            !node.parent.data.abstract_y &&\r\n            node.data.name !== \"root\"\r\n        ) {\r\n            if (node.parent.data.name !== \"root\") {\r\n                current_leaf_height = node.parent.data.abstract_y =\r\n                    current_leaf_height + 1;\r\n                tree.node_order.push(node.parent.data.name);\r\n            }\r\n        }\r\n        tree.max_y = Math.max(tree.max_y, current_leaf_height);\r\n    }\r\n\r\n    if (perform_internal_layout) {\r\n        tree.max_y = 0;\r\n        tree.node_order = [];\r\n        internal_node_layout(tree.nodes);\r\n        const root =\r\n            tree.getNodeByName(\"root\") || tree.getNodeByName(\"new_root\");\r\n        root.data.abstract_y =\r\n            root.children\r\n                .map((child) => child.data.abstract_y)\r\n                .reduce((a, b) => a + b, 0) / root.children.length;\r\n    } else {\r\n        node_layout(tree.nodes);\r\n        tree.max_y = current_leaf_height;\r\n    }\r\n}\r\n\r\nfunction getColorScale(tree, highlightBranches) {\r\n    if (!highlightBranches) return null;\r\n\r\n    if (typeof highlightBranches === \"boolean\") {\r\n        return tree.parsed_tags && highlightBranches\r\n            ? scaleOrdinal().domain(tree.parsed_tags).range(schemeCategory10)\r\n            : null;\r\n    }\r\n    const pairs = _.pairs(highlightBranches);\r\n    return scaleOrdinal()\r\n        .domain(pairs.map((p) => p[0]))\r\n        .range(pairs.map((p) => p[1]));\r\n}\r\n\r\nfunction Phylotree(props) {\r\n    const [tooltip, setTooltip] = useState(false);\r\n    const { width, height, maxLabelWidth } = props;\r\n    const [isOpen, setIsOpen] = useState(false);\r\n    const container = useRef();\r\n    useEffect(() => {\r\n        setIsOpen(false);\r\n\r\n        window.addEventListener(\"mousedown\", handleClickOutside);\r\n        return () => {\r\n            window.removeEventListener(\"mousedown\", handleClickOutside);\r\n        };\r\n    }, [props.reroot, props.collapsed]);\r\n    const handleClickOutside = (event) => {\r\n        if (container.current && !container.current.contains(event.target)) {\r\n            setIsOpen(false);\r\n        }\r\n    };\r\n\r\n    var { tree, newick } = props;\r\n    if (!tree && !newick) {\r\n        return <g />;\r\n    } else if (!tree) {\r\n        tree = new phylotree(newick);\r\n        console.log(tree.getNewick());\r\n        if (props.collapsed) {\r\n            const c = [];\r\n            props.collapsed.forEach(function (node) {\r\n                for (let n of tree.getNodes()) {\r\n                    if (!tree.isLeafNode(n)) {\r\n                        if (node.data.name === n.data.name) {\r\n                            c.push(n);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            toggleCollapse(tree, c);\r\n            placenodes(\r\n                tree,\r\n                props.internalNodeLabels,\r\n                props.accessor,\r\n                props.sort,\r\n                c\r\n            );\r\n        }\r\n        if (!props.skipPlacement) {\r\n            placenodes(\r\n                tree,\r\n                props.internalNodeLabels,\r\n                props.accessor,\r\n                props.sort\r\n            );\r\n        }\r\n    }\r\n\r\n    function attachTextWidth(node) {\r\n        node.data.text_width = text_width(node.data.name, 14, maxLabelWidth);\r\n        if (node.children) node.children.forEach(attachTextWidth);\r\n    }\r\n    attachTextWidth(tree.nodes);\r\n    const sorted_tips = tree\r\n        .getTips()\r\n        .sort((a, b) => b.data.abstract_x - a.data.abstract_x);\r\n    var rightmost = width;\r\n    for (let i = 0; i < sorted_tips.length; i++) {\r\n        let tip = sorted_tips[i];\r\n        rightmost = width - tip.data.text_width;\r\n        let scale = rightmost / tip.data.abstract_x;\r\n        let none_cross = sorted_tips\r\n            .map((tip) => {\r\n                const tip_x = tip.data.abstract_x * scale,\r\n                    text_x = width - tip.data.text_width,\r\n                    this_doesnt_cross = Math.floor(tip_x) < Math.ceil(text_x);\r\n                return this_doesnt_cross;\r\n            })\r\n            .every((x) => x);\r\n        if (none_cross) break;\r\n    }\r\n    const x_scale = scaleLinear().domain([0, tree.max_x]).range([0, rightmost]),\r\n        y_scale = scaleLinear()\r\n            .domain([0, tree.max_y])\r\n            .range([props.includeBLAxis ? 60 : 0, height]),\r\n        color_scale = getColorScale(tree, props.highlightBranches);\r\n\r\n    return (\r\n        <div class=\"col-md-12\">\r\n            <SVG width={width + 100} height={height + 100}>\r\n                <g transform={props.transform}>\r\n                    <defs></defs>\r\n                    {/* {props.includeBLAxis ? <g>\r\n      <text\r\n        x={x_scale(tree.max_x/2)}\r\n        y={10}\r\n        alignmentBaseline='middle'\r\n        textAnchor='middle'\r\n        fontFamily='Courier'\r\n      >\r\n        Substitutions per site\r\n      </text>\r\n      <AxisTop\r\n        transform={`translate(0, 40)`}\r\n        scale={x_scale}\r\n      />\r\n    </g> : null } */}\r\n                    {tree.links.map((link) => {\r\n                        const source_id = link.source.unique_id,\r\n                            target_id = link.target.unique_id,\r\n                            key = source_id + \",\" + target_id,\r\n                            show_label =\r\n                                props.internalNodeLabels ||\r\n                                (props.showLabels &&\r\n                                    tree.isLeafNode(link.target));\r\n                        const show_attribute = props.showAttributes;\r\n                        const show_value1 = props.showValue1;\r\n                        const show_value2 = props.showValue2;\r\n                        const show_value3 = props.showValue3;\r\n                        const show_value4 = props.showValue4;\r\n                        const show_value5 = props.showValue5;\r\n                        const round1 = props.round1;\r\n                        const round2 = props.round2;\r\n                        const round3 = props.round3;\r\n                        const round4 = props.round4;\r\n                        const round5 = props.round5;\r\n                        return (\r\n                            <Branch\r\n                                tree={tree}\r\n                                key={key}\r\n                                xScale={x_scale}\r\n                                yScale={y_scale}\r\n                                colorScale={color_scale}\r\n                                link={link}\r\n                                showLabel={show_label}\r\n                                showAttribute={show_attribute}\r\n                                showValue1={show_value1}\r\n                                showValue2={show_value2}\r\n                                showValue3={show_value3}\r\n                                showValue4={show_value4}\r\n                                showValue5={show_value5}\r\n                                round1={round1}\r\n                                round2={round2}\r\n                                round3={round3}\r\n                                round4={round4}\r\n                                round5={round5}\r\n                                maxLabelWidth={maxLabelWidth}\r\n                                width={width}\r\n                                alignTips={props.alignTips}\r\n                                branchStyler={props.branchStyler}\r\n                                labelStyler={props.labelStyler}\r\n                                tooltip={props.tooltip}\r\n                                setTooltip={setTooltip}\r\n                                setIsOpen={setIsOpen}\r\n                                isOpen={props.isOpen}\r\n                            />\r\n                        );\r\n                    })}\r\n                    {tooltip ? (\r\n                        <props.tooltip\r\n                            width={props.width}\r\n                            height={props.height}\r\n                            {...tooltip}\r\n                        />\r\n                    ) : null}{\" \"}\r\n                </g>\r\n            </SVG>\r\n            <div ref={container}>\r\n                {isOpen ? <props.isOpen {...isOpen} /> : null}{\" \"}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\nPhylotree.defaultProps = {\r\n    showLabels: true,\r\n    skipPlacement: false,\r\n    maxLabelWidth: 20,\r\n    alignTips: \"left\",\r\n    accessor: default_accessor,\r\n    branchStyler: null,\r\n    labelStyler: null,\r\n    tooltip: null,\r\n    includeBLAxis: false,\r\n};\r\n\r\nexport default Phylotree;\r\nexport { placenodes };\r\n","D:\\app test\\phylotree-react\\src\\lib\\components\\tooltip_container.jsx",[],"D:\\app test\\phylotree-react\\src\\lib\\components\\text_width.jsx",[],"D:\\app test\\phylotree-react\\src\\lib\\components\\svg.jsx",[],"D:\\app test\\phylotree-react\\src\\lib\\components\\branch.jsx",[],{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":292,"column":21,"nodeType":"49","endLine":298,"endColumn":22},{"ruleId":"47","severity":1,"message":"48","line":308,"column":21,"nodeType":"49","endLine":314,"endColumn":22},{"ruleId":"50","severity":1,"message":"51","line":380,"column":33,"nodeType":"49","endLine":380,"endColumn":67},{"ruleId":"50","severity":1,"message":"51","line":391,"column":33,"nodeType":"49","endLine":391,"endColumn":68},{"ruleId":"52","severity":1,"message":"53","line":43,"column":15,"nodeType":"54","messageId":"55","endLine":43,"endColumn":24},"no-native-reassign",["56"],"no-negated-in-lhs",["57"],"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","array-callback-return","Array.prototype.map() expects a return value from function.","FunctionExpression","expectedInside","no-global-assign","no-unsafe-negation"]